// Псевдомасив arguments​

// Доступ до списку всіх аргументів можна отримати за допомогою спеціальної змінної arguments,
//  яка доступна тільки всередині функції і зберігає всі аргументи у якості псевдомасиву.

// Псевдомасив - колекція з властивістю length і можливістю звернутися до елементу за індексом,
//  але відсутністю більшості методів для роботи з масивом.

// Розглянемо приклад використання arguments у функції, яка множить будь-яку кількість аргументів:



function multiply() {
  let total = 1;

  for (const argument of arguments) {
    total *= argument;
  }

  return total;
}

console.log(multiply(1, 2, 3)); //  6
console.log(multiply(1, 2, 3, 4)); //  24
console.log(multiply(1, 2, 3, 4, 5)); //  120

    //  -  ----------  Перетворення псевдомасиву

// Зазвичай псевдомасив необхідно перетворити у повноцінний масив,
//     оскільки у псевдомасиву відсутні методи масиву, наприклад slice() або includes().
//     На практиці застосовують декілька основних способів.

// Використовуючи метод Array.from(), який створить масив із псевдомасиву.


function fn() {
  // Змінна args буде містити повноцінний масив
  const args = Array.from(arguments);
}


// Використовуючи операцію ... (rest), вона дозволяє зібрати будь - яку кількість елементів,
// у нашому випадку аргументів, в масив, і зберегти його в змінну.Збираємо всі аргументи,
//  використовуючи операцію rest безпосередньо в підписі функції.



function fn(...args) {
  // Змінна args буде містити повноцінний масив
}


//  -      ------------   ЦІКАВО
// Операція rest детальніше розглядається далі на курсі, тут показаний один
//  з її можливих варіантів застосування.



//  - - ----------------------------------------------------------

// Патерн «Раннє повернення» - це спосіб використовувати можливість дострокового
//  повернення з функції за допомогою оператора return.Використовуючи цей прийом,
//  ми отримуємо чистіший, плоскіший і зрозуміліший код, який простіше рефакторити.



// Виділимо всі перевірки умов в окремі оператори if, після чого додамо код,
//  що знаходиться в тілі else. В ідеальному випадку, повинен вийти плоский список
//  умовних операторів, що йдуть один за одним, а в кінці - блок, який виконається тільки
  // у тому випадку, якщо не виконається жоден if.



function withdraw(amount, balance) {
  // Якщо умова виконується, викликається console.log
  // і вихід із функції. Код після тіла if не виконається.
  if (amount === 0) {
    console.log("Для проведення операції введіть суму більшу за нуль");
    return;
  }

  // Якщо умова першого if не виконалась, його тіло пропускається
  // та інтерпретатор доходе до другого if.
  // Якщо умова виконується, викликається console.log і вихід із функції.
  // Код, що знаходиться після тіла if, не виконається.
  if (amount > balance) {
    console.log("Недостатньо коштів на рахунку");
    return;
  }

  // Якщо жоден із попередніх if не виконався,
  // інтерпретатор доходить до цього коду і виконує його.
  console.log("Операція зняття коштів проведена");
}

withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
withdraw(500, 300); // "Недостатньо коштів на рахунку"
withdraw(100, 300); // "Операція зняття коштів проведена"


// Функціональний вираз

// ​

// Функціональний вираз (function expression) - звичайне оголошення змінної, значенням якої буде функція. Альтернативний спосіб оголошення функції.



// Оголошення функції (function declaration)
function multiply(x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
}

// Функціональний вираз (function expression)
const multiply = function (x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
};


/


// ❌ Помилка! Не працює виклик до оголошення
multiply(1, 2, 3);

const multiply = function (x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
};

// ✅ Працює виклик після оголошення
multiply(4, 5, 6);



// A оголошення функції можна викликати до місця її створення в коді.



// ✅ Працює виклик до оголошення
multiply(1, 2, 3);

function multiply(x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
}

// ✅ Працює виклик після оголошення
multiply(4, 5, 6);



// ЦІКАВО
// Не важливо, який синтаксис використовувати, важливо, щоб код в проекті був однорідним.Тобто необхідно намагатися не змішувати оголошення функції з функціональними виразами.

